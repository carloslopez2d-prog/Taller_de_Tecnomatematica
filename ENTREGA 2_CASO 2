%% PINN Caso B: Solución Oscilatoria
% Ecuación: y' = cos(4*pi*x) - 0.5*y   |   y(0) = 0
clear; clc; close all;
%% 1. Configuración de la Red
numNeurons = 8;
layers = [
   featureInputLayer(1, 'Name', 'input')
   fullyConnectedLayer(numNeurons); tanhLayer
   fullyConnectedLayer(numNeurons); tanhLayer
   fullyConnectedLayer(numNeurons); tanhLayer
   fullyConnectedLayer(numNeurons); tanhLayer
   fullyConnectedLayer(1, 'Name', 'output')
];
pinn = dlnetwork(layers);
%% 2. Parámetros de Entrenamiento y Datos
numEpochs = 3000;
learningRate = 0.01; % Un poco más bajo para que no oscile el error
gifFilename = 'pinn_caso_b.gif';
% Dominio (Más puntos para ver bien las ondas)
x_physics = dlarray(linspace(0, 2, 400), 'CB');
x0 = dlarray(0, 'CB');
y0_target = 0; % Condición inicial del enunciado B
% Solución de referencia (ODE45)
[t_ref, y_ref] = ode45(@(t,y) cos(4*pi*t) - 0.5*y, [0 2], 0);
averageGrad = []; averageSqGrad = [];
%% 3. Gráficos y Preparación
fig = figure('Color', 'w', 'Position', [100 100 1000 450]);
subplot(1,2,1);
hLoss = animatedline('Color', [0.5 0 0.5], 'LineWidth', 1.5);
title('Pérdida (Loss)'); grid on; set(gca, 'YScale', 'log');
subplot(1,2,2);
plot(t_ref, y_ref, 'k-', 'LineWidth', 1.5, 'DisplayName', 'Exacta (ODE45)'); hold on;
hPinn = plot(NaN, NaN, 'r--', 'LineWidth', 2.5, 'DisplayName', 'PINN');
title('Caso B: y'' = cos(4\pi x) - 0.5y'); ylim([-0.6 0.6]); grid on;
legend('Location', 'northeast');
%% 4. Bucle de Entrenamiento
fprintf('Entrenando Caso B...\n');
for epoch = 1:numEpochs
   [loss, grads] = dlfeval(@modelLoss, pinn, x_physics, x0, y0_target);
  
   [pinn, averageGrad, averageSqGrad] = adamupdate(pinn, grads, ...
       averageGrad, averageSqGrad, epoch, learningRate);
  
   if mod(epoch, 50) == 0 || epoch == 1
       currentLoss = double(extractdata(loss));
       addpoints(hLoss, epoch, currentLoss);
      
       y_pred = predict(pinn, x_physics);
       set(hPinn, 'XData', extractdata(x_physics), 'YData', extractdata(y_pred));
       drawnow limitrate;
      
       % GIF
       frame = getframe(fig);
       im = frame2im(frame);
       [imind, cm] = rgb2ind(im, 256);
       if epoch == 1
           imwrite(imind, cm, gifFilename, 'gif', 'Loopcount', inf, 'DelayTime', 0.1);
       else
           imwrite(imind, cm, gifFilename, 'gif', 'WriteMode', 'append', 'DelayTime', 0.1);
       end
   end
end
%% 5. Función de Pérdida (Physics-Informed)
function [loss, grads] = modelLoss(net, x_phys, x0, y0_target)
   y = forward(net, x_phys);
   dy_dx = dlgradient(sum(y, 'all'), x_phys, 'EnableHigherDerivatives', true);
  
   % --- ECUACIÓN FÍSICA CASO B ---
   % y' = cos(4pi*x) - 0.5y
   % Residuo = y' - (cos(...) - 0.5y)
   rhs = cos(4*pi*x_phys) - 0.5*y;
   f = dy_dx - rhs;
  
   loss_physics = mean(f.^2);
  
   % Condición de Borde
   y0_pred = forward(net, x0);
   loss_boundary = (y0_pred - y0_target)^2;
  
   loss = loss_physics + loss_boundary;
   grads = dlgradient(loss, net.Learnables);
end

%% PINN Caso B: Solución Oscilatoria
% Ecuación: y' = cos(4*pi*x) - 0.5*y   |   y(0) = 0
clear; clc; close all;
%% 1. Configuración de la Red
% Aumentamos a 20 neuronas porque el coseno requiere más "curvas"
numNeurons = 20;
layers = [
   featureInputLayer(1, 'Name', 'input')
  
   fullyConnectedLayer(numNeurons); tanhLayer
   fullyConnectedLayer(1, 'Name', 'output')
];
pinn = dlnetwork(layers);
%% 2. Parámetros de Entrenamiento y Datos
numEpochs = 3000;
learningRate = 0.01; % Un poco más bajo para que no oscile el error
gifFilename = 'pinn_caso_b2.gif';
% Dominio (Más puntos para ver bien las ondas)
x_physics = dlarray(linspace(0, 2, 400), 'CB');
x0 = dlarray(0, 'CB');
y0_target = 0; % Condición inicial del enunciado B
% Solución de referencia (ODE45)
[t_ref, y_ref] = ode45(@(t,y) cos(4*pi*t) - 0.5*y, [0 2], 0);
averageGrad = []; averageSqGrad = [];
%% 3. Gráficos y Preparación
fig = figure('Color', 'w', 'Position', [100 100 1000 450]);
subplot(1,2,1);
hLoss = animatedline('Color', [0.5 0 0.5], 'LineWidth', 1.5);
title('Pérdida (Loss)'); grid on; set(gca, 'YScale', 'log');
subplot(1,2,2);
plot(t_ref, y_ref, 'k-', 'LineWidth', 1.5, 'DisplayName', 'Exacta (ODE45)'); hold on;
hPinn = plot(NaN, NaN, 'r--', 'LineWidth', 2.5, 'DisplayName', 'PINN');
title('Caso B: y'' = cos(4\pi x) - 0.5y'); ylim([-0.6 0.6]); grid on;
legend('Location', 'northeast');
%% 4. Bucle de Entrenamiento
fprintf('Entrenando Caso B...\n');
for epoch = 1:numEpochs
   [loss, grads] = dlfeval(@modelLoss, pinn, x_physics, x0, y0_target);
  
   [pinn, averageGrad, averageSqGrad] = adamupdate(pinn, grads, ...
       averageGrad, averageSqGrad, epoch, learningRate);
  
   if mod(epoch, 50) == 0 || epoch == 1
       currentLoss = double(extractdata(loss));
       addpoints(hLoss, epoch, currentLoss);
      
       y_pred = predict(pinn, x_physics);
       set(hPinn, 'XData', extractdata(x_physics), 'YData', extractdata(y_pred));
       drawnow limitrate;
      
       % GIF
       frame = getframe(fig);
       im = frame2im(frame);
       [imind, cm] = rgb2ind(im, 256);
       if epoch == 1
           imwrite(imind, cm, gifFilename, 'gif', 'Loopcount', inf, 'DelayTime', 0.1);
       else
           imwrite(imind, cm, gifFilename, 'gif', 'WriteMode', 'append', 'DelayTime', 0.1);
       end
   end
end
%% 5. Función de Pérdida (Physics-Informed)
function [loss, grads] = modelLoss(net, x_phys, x0, y0_target)
   y = forward(net, x_phys);
   dy_dx = dlgradient(sum(y, 'all'), x_phys, 'EnableHigherDerivatives', true);
  
   % --- ECUACIÓN FÍSICA CASO B ---
   % y' = cos(4pi*x) - 0.5y
   % Residuo = y' - (cos(...) - 0.5y)
   rhs = cos(4*pi*x_phys) - 0.5*y;
   f = dy_dx - rhs;
  
   loss_physics = mean(f.^2);
  
   % Condición de Borde
   y0_pred = forward(net, x0);
   loss_boundary = (y0_pred - y0_target)^2;
  
   loss = loss_physics + loss_boundary;
   grads = dlgradient(loss, net.Learnables);
end

